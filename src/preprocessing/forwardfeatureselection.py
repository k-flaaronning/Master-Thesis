# -*- coding: utf-8 -*-
"""ForwardFeatureSelection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11q-dfBg6hH_cBZRHI9RxNzpMtS4a4GUW
"""

#------- Fix the usage of GPU -----------------------------------------------------

#' ' means CPU whereas '/device:G:0' means GPU
import tensorflow as tf
print(tf.test.gpu_device_name())

# memory footprint support libraries/code
!ln -sf /opt/bin/nvidia-smi /usr/bin/nvidia-smi
!pip install gputil
!pip install psutil
!pip install humanize
import psutil
import humanize
import os
import GPUtil as GPU
GPUs = GPU.getGPUs()
# XXX: only one GPU on Colab and isn’t guaranteed
gpu = GPUs[0]
def printm():
 process = psutil.Process(os.getpid())
 print("Gen RAM Free: " + humanize.naturalsize( psutil.virtual_memory().available ), " | Proc size: " + humanize.naturalsize( process.memory_info().rss))
 print("GPU RAM Free: {0:.0f}MB | Used: {1:.0f}MB | Util {2:3.0f}% | Total {3:.0f}MB".format(gpu.memoryFree, gpu.memoryUsed, gpu.memoryUtil*100, gpu.memoryTotal))
printm()

#!kill -9 -1

from google.colab import drive
drive.mount('/content/drive')

#!google-drive-ocamlfuse -cc

# Code to read csv file into colaboratory:
!pip install -U -q PyDrive
from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials

auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)

downloaded = drive.CreateFile({'id':'1oF7toJFWt-tox50GM8I2AT_fvYITkgzZ'}) # replace the id with id of file you want to access
downloaded.GetContentFile('Data_namechanged.pkl')

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

import tensorflow as tf

from tensorflow import keras
from tensorflow.keras import layers


from sklearn.preprocessing import MinMaxScaler, StandardScaler

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Input, Dense, GRU, Embedding
from tensorflow.keras.optimizers import RMSprop
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint, TensorBoard, ReduceLROnPlateau
from tensorflow.keras.backend import square, mean
from tensorflow.keras.losses import MeanSquaredError

def batch_generator(batch_size, sequence_length, num_x_signals, num_y_signals, num_train, x_train_scaled, y_train_scaled):
   
    while True:
        x_shape = (batch_size, sequence_length, num_x_signals)
        x_batch = np.zeros(shape=x_shape, dtype=np.float16)

        y_shape = (batch_size, sequence_length, num_y_signals)
        y_batch = np.zeros(shape=y_shape, dtype=np.float16)

        for i in range(batch_size):
            idx = np.random.randint(num_train - sequence_length)
            
            x_batch[i] = x_train_scaled[idx:idx+sequence_length]
            y_batch[i] = y_train_scaled[idx:idx+sequence_length]
        
        yield (x_batch, y_batch)

warmup_steps = 50
def loss_mse_warmup(y_true, y_pred):
    y_true_slice = y_true[:, warmup_steps:, :]
    y_pred_slice = y_pred[:, warmup_steps:, :]
    mse = mean(square(y_true_slice - y_pred_slice))
    
    return mse

def r_square(y_true, y_pred):
    from tensorflow.keras import backend as K
    SS_res =  K.sum(K.square(y_true - y_pred)) 
    SS_tot = K.sum(K.square(y_true - K.mean(y_true))) 
    return ( 1 - SS_res/(SS_tot + K.epsilon()) )

data = pd.read_pickle('Data_namechanged.pkl')

if False: # Features arranges by correlation with target variable
  data = data[['Control Flow Indicator CC1', 'Suction Gas Pressure CB2',
        'Suction Gas Temperature CC2', 'Discharge Pressure GTC',
        'Speed Set Point GTC', 'Producer Speed GTC', 'RPM Turbine C',
        'Control Flow Indicator CB3.1', ' T5 GTC',
        'Discharge Gas Temperature CB2', 'OPRA3 Gas Temperature',
        ' Discharge Gas Temperature CC1', 'Suction Gas Pressure CC2',
        'Discharge Gas Temprature CC3', 'Discharge Gas Temprature CB3',
        'Suction Gas Temperature CC1', ' Discharge Gas Temperature CC2',
        'Discharge Gas Pressure CC2', 'Suction Gas Pressure CC1',
        'RPM Turbine B', 'Suction Gas Pressure CB3', 'Wind Direction 2 ',
        'OPRA1 Gas Temperature', 'Suction Gas Pressure CC3',
        'Control Flow Indicator CC2', 'Suction Gas Pressure CA2',
        'Discharge Gas Pressure CA3', 'Discharge Gas Pressure CB2', ' T5 GTB',
        'RPM Turbine A', 'Speed Set Point GTA', 'Discharge Gas Pressure CA1',
        'Discharge Gas Pressure CC3', 'T5 GTA', 'Discharge Gas Temperature CB1',
        'Discharge Gas Temperature CA1', 'Air Inlet Temperature - GTA',
        'Suction Gas Temperature CA1', ' Control Flow Indicator CA3',
        'OPRA2 Gas Temperature', 'Suction Gas Pressure CA1',
        'Suction Gas Temperature CB2', 'Discharge Gas Pressure CB3',
        'Suction Gas Temprature CA3', 'Deg Heading',
        'Control Flow Indicator CB3', 'Suction Gas Temprature CB3',
        'Control Flow Indicator CB2', 'Discharge Pressure GTA', 'HP Flare']]


if True: # Features arranged by single model performance
  data = data[['Speed Set Point GTA', 'Suction Gas Temperature CC2',
        'Producer Speed GTC', 'RPM Turbine A', ' Discharge Gas Temperature CC1',
        'Discharge Pressure GTC', ' T5 GTC', 'RPM Turbine C',
        'Suction Gas Pressure CA2', 'Control Flow Indicator CC2',
        'Discharge Gas Pressure CA3', 'Discharge Pressure GTA',
        'Discharge Gas Pressure CC2', 'Discharge Gas Temprature CC3',
        'Discharge Gas Pressure CA1', 'T5 GTA', 'Control Flow Indicator CB3.1',
        'Suction Gas Pressure CC3', 'Suction Gas Temperature CC1',
        'Control Flow Indicator CC1', ' Control Flow Indicator CA3',
        'Wind Direction 2 ', 'Discharge Gas Pressure CC3',
        'OPRA2 Gas Temperature', 'Suction Gas Temprature CB3',
        'Speed Set Point GTC', 'OPRA3 Gas Temperature',
        ' Discharge Gas Temperature CC2', 'Suction Gas Pressure CB2',
        'Suction Gas Pressure CC1', 'Suction Gas Temprature CA3',
        'Discharge Gas Temperature CA1', 'Deg Heading',
        'Suction Gas Pressure CC2', 'Suction Gas Temperature CA1',
        'Air Inlet Temperature - GTA', 'Discharge Gas Temprature CB3',
        'Discharge Gas Temperature CB2', 'Suction Gas Pressure CB3',
        'Suction Gas Temperature CB2', 'Discharge Gas Pressure CB3',
        'Discharge Gas Pressure CB2', 'Suction Gas Pressure CA1',
        'OPRA1 Gas Temperature', 'Control Flow Indicator CB3',
        'Control Flow Indicator CB2', 'Discharge Gas Temperature CB1',
        ' T5 GTB', 'RPM Turbine B', 'HP Flare']]

data_col = data.columns.drop('HP Flare')

data = data.interpolate(method='linear') 
#shift_steps = 5
df_targets = data.pop('HP Flare')#.shift(-shift_steps)

#----------- Tentative Model --------------------

split = [0.5,0.6,0.7,0.8,0.9]
split = [0.8]
def run_model(data):
  final_mse = []
  for temp_split in split:
    x_data = data.values
    y_data = df_targets.values.reshape(-1,1)
    if False:# True if evaluating each feature seperately, otherwise False
      x_data = x_data.reshape(-1,1)

    #Split dataset
    num_data = len(x_data)
    train_split = temp_split
    num_train = int(train_split * num_data)
    num_test = num_data - num_train

    x_train = x_data[0:num_train]
    x_test = x_data[num_train:]
    y_train = y_data[0:num_train]
    y_test = y_data[num_train:]

    num_x_signals = x_data.shape[1]
    num_y_signals = y_data.shape[1]

    #Scale the data
    x_scaler = MinMaxScaler()
    x_train_scaled = x_scaler.fit_transform(x_train)
    x_test_scaled = x_scaler.transform(x_test)
    y_scaler = MinMaxScaler()
    y_train_scaled = y_scaler.fit_transform(y_train)
    y_test_scaled = y_scaler.transform(y_test)

    batch_size = 256
    sequence_length = 100

    #
    generator = batch_generator(batch_size, sequence_length, num_x_signals, num_y_signals, num_train, x_train_scaled, y_train_scaled)

    validation_data = (np.expand_dims(x_test_scaled, axis=0), np.expand_dims(y_test_scaled, axis=0))
    model_mse = []
    num_runs = 10
    for i in range(num_runs):
      #Model Architecture
      model = Sequential()
      model.add(GRU(units=512,
                    return_sequences=True,
                    input_shape=(None, num_x_signals,)))
      model.add(Dense(num_y_signals, activation='sigmoid'))

      optimizer = RMSprop(lr=1e-3)
      model.compile(loss=loss_mse_warmup, optimizer=optimizer, metrics = ['mse', r_square])

      path_checkpoint = 'best_model'
      callback_checkpoint = ModelCheckpoint(filepath=path_checkpoint, monitor='val_loss', verbose=1, save_weights_only=True, save_best_only=True)
      callback_early_stopping = EarlyStopping(monitor='val_loss', patience=3, verbose=1)
      callbacks = [callback_checkpoint, callback_early_stopping]

    
      model.fit(x=generator,
                epochs=10,
                steps_per_epoch=100,
                validation_data=validation_data, 
                callbacks = callbacks)
      try:
        model.load_weights(path_checkpoint)
        print('Success')
      except Exception as error:
        print("Error trying to load checkpoint.")
        print(error)

      # Input-signals for the model.
      x = np.expand_dims(x_test_scaled, axis=0)

      # Use the model to predict the output-signals.
      y_pred = model.predict(x)
      y_pred_rescaled = y_scaler.inverse_transform(y_pred[0])

      temp_mse = np.sqrt(np.mean(np.square(y_pred_rescaled - y_test)))
      temp_mse = temp_mse.item()
      model_mse.append(temp_mse)

      print('Model finished')

    print('Split finished')
    final_mse.append(np.mean(temp_mse))

  return_final_mse = np.array(final_mse)

  return return_final_mse

if False:
  output = np.zeros((len(data.columns)))
  output_std = np.zeros((len(data.columns)))
  for col in range(len(data.columns)):
    temp_data = data.iloc[:,col]
    output[col] = run_model(temp_data).mean()
    output_std[col] = run_model(temp_data).std()
    print('Ferdig med {} variabel!!!!!!!!!! \n'.format(col))

# trans = pd.DataFrame([[4493.45051966, 4567.32430355, 4447.67192095, 4467.49261445, 4546.32401554,
#  4453.44086105 ,4474.22841351, 4487.86628354 ,4472.32131248, 4758.91985488,
#  4556.64830266, 4466.71776301, 4675.14146677, 4480.45087204, 4757.8863935,
#  4490.40857608 ,4561.85246437 ,4479.26116477, 4587.26286093, 4853.36559637,
#  4761.94541323, 4502.64391994, 4784.72715962, 4489.95651649, 4476.09486597,
#  4474.33325282, 4477.4754011 , 4770.69611009, 4840.63062594, 4465.19893817,
#  4433.72061045, 4482.85060681, 4522.21841741, 4483.25241045, 4819.74815868,
#  4616.76442281 ,4725.23300805, 4675.55669443 ,4497.60186949 ,4522.98647098,
#  4775.3348579 , 4762.75471497, 4765.34059376, 4611.82941341, 4642.35638927,
#  4815.56552126 ,4530.91955066, 4818.2560885  ,4478.6640406 ]], columns = data_col)
# trans = trans.sort_values(by = 0, axis = 1)
# print(trans.columns)

if True:
  output = np.zeros((len(data.columns)))
  output_std = np.zeros((len(data.columns)))
  for col in range(len(data.columns)):
    temp_data = data.iloc[:,:col+1]
    output[col] = run_model(temp_data).mean()
    output_std[col] = run_model(temp_data).std()
    print('Ferdig med {} variabel!!!!!!!!!! \n'.format(col))

print(output)
# Test med 49 variables arranged by model scores
# [4399.83237096 4442.16023514 4408.55962626 4392.97026537 4366.76570862
#  4339.7950844  3651.30896096 3638.50821008 3644.06794054 3661.3079354
#  3677.62296979 3616.01337319 4268.21519234 3658.62270191 4260.09601477
#  4250.95374646 3585.1629635  4245.34134567 3592.48771251 3591.19717737
#  3577.8964913  4235.72776076 3584.11097236 3583.91819225 3609.55891055
#  3596.02110218 3578.29585229 3592.777485   3590.00977622 3585.09115448
#  3541.94337443 3609.62739938 3744.68976772 3574.26905905 3496.74778707
#  3600.27590672 3527.86659003 3410.24941831 3498.44388961 3327.47641449
#  3364.07208629 3241.60102412 3346.67137973 3242.68078579 3276.16570192
#  3212.14109036 3253.08420806 3213.50726674 3222.2991888 ]

plt.plot(np.arange(len(output)), output)
plt.ylabel('RSME')
plt.xlabel('Number of Features')

# Test med 49 variabler arranged by correlation
# [4494.2771004  4493.28472491 4440.88274885 4401.1012574  4055.95440839
#  3777.50123514 3775.76044576 4322.32965708 3778.66503589 4317.44269598
#  4272.21278226 4279.88597865 3719.09396456 3548.48174839 4287.7068122
#  3480.29090883 3587.41497069 3474.26531071 3493.84007994 3380.27026752
#  3389.16395482 3384.36203369 3366.60781388 3389.65011603 3427.09347291
#  3365.96204411 3336.60580125 3383.94586132 3374.1732921  3268.55868526
#  3269.3791767  3257.61456255 3259.08759914 3177.20588019 3242.35040923
#  3209.85786381 3196.54061303 3263.16407159 3262.00600703 3149.20541682
#  3234.76746731 3162.53966447 3201.16788602 3240.10539007 3147.65495694
#  3221.86547558 3274.47732347 3216.55738878 3151.11526881]

plot2 = [4494.2771004,  4493.28472491, 4440.88274885, 4401.1012574 , 4055.95440839,
 3777.50123514, 3775.76044576 ,4322.32965708, 3778.66503589 ,4317.44269598,
 4272.21278226, 4279.88597865, 3719.09396456, 3548.48174839, 4287.7068122,
 3480.29090883 ,3587.41497069 ,3474.26531071, 3493.84007994, 3380.27026752,
 3389.16395482 ,3384.36203369 ,3366.60781388, 3389.65011603, 3427.09347291,
 3365.96204411, 3336.60580125, 3383.94586132, 3374.1732921 , 3268.55868526,
 3269.3791767  ,3257.61456255, 3259.08759914 ,3177.20588019, 3242.35040923,
 3209.85786381 ,3196.54061303, 3263.16407159 ,3262.00600703 ,3149.20541682,
 3234.76746731 ,3162.53966447 ,3201.16788602 ,3240.10539007 ,3147.65495694,
 3221.86547558 ,3274.47732347 ,3216.55738878 ,3151.11526881]
print(plot2)
plt.plot(np.arange(len(plot2)), plot2)
plt.ylabel('RSME')
plt.xlabel('Number of Features')

# 3 runder
#[4509.71609075 4494.25743979 4438.91232333 4472.77822665 3443.63430378 3424.07663588 3443.76406145 4369.86443511 3187.89658618 3193.04358447 3187.71175447 3226.93365566 3290.41750951 3196.84032058 3214.58587175 3270.43330197 3199.23389087 3307.92177162 3251.47690192 3254.64543885 3237.45608589 3159.04362983]

#4 Runder
# [4470.68045795 4510.57701747 4429.949549   4405.11052771 4396.13607813
#  3469.3065337  3422.53626907 4341.75876019 3190.75390252 3187.98171992
#  3211.1465951  3243.65496304 3227.61699904 3191.03849413 3201.46216354
#  3258.06451997 3249.76425858 3156.09533267 3216.63131002 3196.12444241
#  4147.17257321 3187.2804187 ]

#1 Runde #Suction Gas Pressure CC2 er jævelen
#[4519.28849722 4398.68983224 4353.80043163 4478.89734028 3411.00476602
#  4391.4752661  3397.18718501 3414.56769394 3221.28517337 3204.03627244
#  3202.78460186 3270.85123    3206.28808291 3255.56741511 3220.1248568
#  3223.86251139 3253.71937741 3178.01008866 3200.26374931 3193.5547304
#  3184.28793569 3156.89688649]


#NY og bedre!!!!!!!

# [4485.8803341  4561.53156496 4500.80334229 4395.3650879  4378.87032418
#  4401.84338541 4366.51704454 3451.45489612 3514.97953195 3425.20973794
#  3460.30153336 3438.8910537  3421.71623644]